{% extends 'base.html' %}

{% block meta %}
<link rel="stylesheet" type="text/css" href="/media/css/game.css" type="text/css" />
{% endblock meta %}

{% block header_title %}
Fuck ya bitches
{% endblock header_title %}

{% block style %}
{% endblock style %}

{% block content %}

    <ul id="phases">
        <li class="active draw">
            Draw & heal
        </li>
        <li class="play play_1">
            Play (offensive)
        </li>
        <li class="attack">
            Attack
        </li>
        <li class="play play_2">
            Play (strategic)
        </li>
        <li class="active draw">
            AI Draw & heal
        </li>
        <li class="play play_1">
            AI Play (offensive)
        </li>
        <li class="attack">
            AI Attack
        </li>
        <li class="play play_2">
            AI Play (strategic)
        </li>
    </ul>

    <div class="ai board">
        {% for node in board %}
        <div class="node empty" name="{{ node.pk }}" style="left:{{node.board_x_ai}}px;top:{{node.board_y_ai}}px;">
            </div>
        {% endfor %}
    </div>

    <div id="ai_tech" class="ai tech" name="tech">
        <h1>T1</h1>
    </div>
    <div id="ai_life" class="ai life">
        <h1>10</h1> 
    </div>

    <div class="friendly board">
        {% for node in board %}
        <div class="node empty" name="{{ node.pk }}" style="left:{{node.board_x_friendly}}px;top:{{node.board_y_friendly}}px;">
            </div>
        {% endfor %}
    </div>

    <ul id="friendly_hand">
    </ul>

    <div id="friendly_tech" class="tech" name="tech">
        <h1>T1</h1>
    </div>
    <div id="friendly_life" class="friendly life">
        <h1>10</h1> 
    </div>

    <form id="current_turn" method="post" action="/playing/end_turn/">
        {% csrf_token %}

        <input name="card1" />
        <input name="node1" />
        <input name="align1" />

        <input name="card2" />
        <input name="node2" />
        <input name="align2" />

        <input name="i_win" type="checkbox" />
    </form>

    <script>

        var UNIT_R = 25;

        var phases = ["draw", "play_1", "attack", "play_2", "ai_draw", "ai_play_1", "ai_attack", "ai_play_2"];
        var phase = -1;

        var tech_level = 1;
        var ai_tech_level = 1;

        var life = { 'friendly': 10, 'ai': 10 };

        var MAX_TECH = 5;

        //hand_cards[card_pk] = card.fields
        var hand_cards = {};

        //the data returned from the server after ending
        //a turn, including what the ai opponent does and
        //which cards you draw
        var turn_data = null;

        var boards = {};
        var board_node_locs = {};
        var board_node_pks = {};

        //same format as hand_cards, but contains
        //every card played so far this game as a
        //lookup for what's already happened
        var played_cards = {};
        
        $(function() {
            boards.friendly = {};
            boards.ai = {};

            {% for node in board %}
                board_node_locs["{{ node.pk }}"] = { "row": {{ node.row }}, "x": {{ node.x }} }; 
                if (! board_node_pks["{{ node.row }}"] ) {
                    board_node_pks["{{ node.row }}"] = {};
                }
                board_node_pks["{{ node.row }}"]["{{ node.x }}"] = "{{ node.pk }}";
            {% endfor %} 

            next_phase();

        });

        function draw_starting_hand() {

            $.ajax({ url: "/playing/draw/",
                success: function(hand_data_text) {
                    //convert to json
                    hand_data = eval('(' + hand_data_text + ')');

                    //clear old cards
                    hand_cards = {};
                    $("#friendly_hand").empty();

                    for (var i = 0; i < hand_data.length; i ++) {
                        var card_json = hand_data[i];

                        //display card in hand area
                        add_card_to_hand(card_json);

                        //track it for lookup when its played
                        hand_cards[card_json.pk] = card_json.fields;
                    }

                    next_phase();
                }
            }); 
        }

        function end_turn() {
            $.post("playing/end_turn/",
                $("#current_turn").serialize(),
                function(data) {
                    turn_data = eval('(' + data + ')');
                    next_phase();
                }
            );
        }

        function next_phase() {

            phase ++;
            cancel_cast();

            if (phase >= phases.length) {
                phase = 0;
                $("#phases li.active").removeClass("active").siblings().first().addClass("active");
            }
            else {
                $("#phases li.active").removeClass("active").parent().children().eq(phase).addClass("active");
            }

            if (phase == 0) {
                if (turn_data) {
                    //draw cards
                    setTimeout( function () {
                        add_card_to_hand( turn_data.player_draw[0] );
                        setTimeout ( function() {
                            add_card_to_hand( turn_data.player_draw[1] );
                            next_phase();
                        }, 200);
                    }, 200); 

                    heal_units("friendly");
                }
                else {
                    //special case first turn
                    draw_starting_hand();
                }
            }
            else if (phase == 1) {
                //do nothing.
                //wait for player to play card
            }
            else if (phase == 2) {
                //begin logic for auto-attacking
                var delay = do_attack_phase("friendly");
                setTimeout(next_phase, delay);
            }
            else if (phase == 3) {
                //do nothing.
                //wait for player to play card
            }
            else if (phase == 4) {
                //ai draw & heal
                heal_units("ai");

                end_turn();
            }
            else if (phase == 5) {
                //ai play 1
                if (turn_data.ai_turn[0].fields.is_tech_1) {
                    ai_tech_up(1); 
                }
                else {
                    var ai_play = turn_data.ai_cards[0].fields;
                    var target = turn_data.ai_turn[0].fields.target_node_1;
                    var align = turn_data.ai_turn[0].fields.target_alignment_1; 
                    //ai summons
                    var node = $(".board.ai .node[name='" + target + "']");
                    ai_cast(ai_play, node);
                }
            } 
            else if (phase == 6) {
                //ai attack
                var delay = do_attack_phase("ai");
                setTimeout(next_phase, delay);
            }
            else if (phase == 7) {
                //ai play 2
                if (turn_data.ai_turn[0].fields.is_tech_2) {
                    ai_tech_up(1); 
                }
                else {
                    var ai_play = turn_data.ai_cards[1].fields;
                    var target = turn_data.ai_turn[0].fields.target_node_2;
                    var align = turn_data.ai_turn[0].fields.target_alignment_2; 
                    var node = $(".board.ai .node[name='" + target + "']");
                    ai_cast(ai_play, node);
                }
            }
        }

        /** returns the number of milliseconds this attack phase will require to animate */
        function do_attack_phase(alignment) { 
            var i = 0;
            var animation_ms = 0;
            $(".board." + alignment + " .node.unit").each( 
                function () { 
                    var approach_dir = (alignment == "friendly" ? "-":"+");
                    var retreat_dir = (alignment == "friendly" ? "+":"-");

                    var to_animate = $(this);

                    //find target
                    //var attacker_id = to_animate.attr("id");
                    var node_id = to_animate.attr("name");

                    var attacker_json = boards[alignment][node_id];

                    var attack_path = do_attack(attacker_json, node_id, alignment);

                    var opponent_alignment = (alignment == "friendly" ? "ai" : "friendly"); 

                    var str = "";
                    var current_animation_step = 0;
                    for (var i = 0; i < attack_path.length; i ++) {
                        str += attack_path[i].drow + "," + attack_path[i].dx + "   "; 

                        if (i == 0) {
                            $(this).animate( { top: "+=0" }, { queue: true, duration: animation_ms } );
                        }

                        animation_ms += 200;
                        $(this).animate(
                            {   top: attack_path[i].drow,
                                left: attack_path[i].dx,
                            },
                            {
                                queue: true,
                                duration: 200,
                                complete: function() {
                                    // what Im doing and to who
                                    var action = attack_path[current_animation_step].action;
                                    var target_node_pk = attack_path[current_animation_step].node_id;

                                    //perform whatever action is relevant for this
                                    //path step
                                    if (action == "damage_player") {
                                        damage_player(opponent_alignment, attacker_json.attack);
                                    }
                                    else if (action == "damage_unit") {
                                        damage_unit(target_node_pk, opponent_alignment, attacker_json.attack); 
                                    } 
                                    current_animation_step ++;
                                },
                            }
                        );
                    }
                    for (i = attack_path.length - 1; i >= 0; i --) {
                        animation_ms += 200;
                        $(this).animate(
                            {   top: attack_path[i].drow_reverse,
                                left: attack_path[i].dx_reverse,
                            },
                            {
                            queue: true,
                            duration:200,
                            }     
                        ); 
                    }
            });
            return animation_ms;
        }

        function set_unit_damage(node_pk, alignment, total_damage) {
            var unit = boards[alignment][node_pk];

            if (!unit) return;

            unit.damage = total_damage;

            var node = $(".board." + alignment + " .node[name='" + node_pk + "']");
            node.children(".unit_piece").html(unit.attack + "/" + (unit.defense - unit.damage) + unit.attack_type[0]); 

            if (unit.damage >= unit.defense) {
                //killed. remove from board.
                boards[alignment][node_pk] = null;
                node.children(".unit_piece").remove(); 
                node.addClass("empty");
                node.removeClass("unit");
            } 
        }
        function damage_unit(node_pk, alignment, delta_damage) {
            var unit = boards[alignment][node_pk];

            if (!unit) return;

            if (!unit.damage) {
                unit.damage = 0;
            }
            set_unit_damage(node_pk, alignment, unit.damage + delta_damage); 
        }
        function heal_units(alignment) {
            for (var node_pk in boards[alignment]) {
                var node = boards[alignment][node_pk];
                set_unit_damage(node_pk, alignment, 0);
            }
        }

        function ai_cast(card, node) { 

            if (card.defense) {

                //create a summon
                node.addClass("unit");
                node.addClass("occupied"); 

                node.removeClass("empty");

                //for lookup of unit behaviour later
                node.attr("id", card.pk);

                played_cards[card.pk] = card; 
                boards["ai"][node.attr("name")] = $.extend(true, {}, card);

                var unit = $("<div class='unit_piece' id='" + card.pk + "'>" + card.attack + "/" + card.defense + card.attack_type[0] + "</div>").appendTo(node);

            }

            next_phase();
        }

        /** 
         * returns a list of node points in format: 
         * { dx:XXX, drow:XXX, [action:damage_unit/damage_player/blocked], node_id:node_pk } 
         */ 
        function do_attack(card_json, node_id, alignment) {

            var starting_alignment = alignment;
            var opponent_alignment = (starting_alignment == "friendly" ? "ai" : "friendly"); 

            var row = board_node_locs[node_id].row;
            var x = board_node_locs[node_id].x;

            var is_searching = true;

            var d_row = 1;

            var path_info = [];

            while (is_searching) {

                if (alignment != starting_alignment) {
                    //we've entered ai territory
                    d_row = -1;
                }
                else if (row == 2) {
                    //breaching ai territory, from front row to front row
                    d_row = 0;
                    alignment = (alignment == "friendly" ? "ai" : "friendly"); 
                }
                else {
                    //moving forward from your back[er] row
                    d_row = 1;
                }

                //check [row-1][x]
                row = row + d_row;
                var old_x = x;

                if (Math.abs(x) > row) {
                    // keep movement inside the triangle.
                    // this is a lazy hack to avoid making a
                    // proper tree structure for this board.
                    // specifically, this maintains the sign of
                    // x while capping it at [row], so r=1, x=-2
                    // becomes r=1, x=-1
                    x = row * x / Math.abs(x);
                }

                //okay, we have our next node!
                var next_node_id = board_node_pks[row][x] 

                var path_node = { node_id: next_node_id };
                if (starting_alignment == "ai") {
                    path_node.drow = "+=100";
                    path_node.drow_reverse = "-=100";
                }
                else {
                    path_node.drow = "-=100";
                    path_node.drow_reverse = "+=100";
                }

                if (old_x < x) {
                    path_node.dx = "+=100";
                    path_node.dx_reverse = "-=100";
                }
                else if (old_x > x) {
                    path_node.dx = "-=100";
                    path_node.dx_reverse = "+=100";
                }
                else { 
                    path_node.dx = "+=0";
                    path_node.dx_reverse = "+=0";
                }

                path_info.push(path_node);

                //is there a guy there?
                var collision_unit = boards[alignment][next_node_id];
                if (collision_unit) {
                    if (alignment == starting_alignment) { 

                        //am i ranged? loop!
                        if (card_json.attack_type == "ranged") {
                            continue;
                        }
                        else {
                            //am i melee? done :*(
                            path_node.action = "blocked";
                            is_searching = false;
                        }
                    }
                    else {
                        //no? ai! hit it!
                        //damage_unit(next_node_id, alignment, card_json.attack); 
                        path_node.action = "damage_unit";
                        is_searching = false;
                    }
                }
                else if (alignment == opponent_alignment && row <= 0) {
                    //is it 0,0? hit the player!
                    is_searching = false; 

                    attack = card_json.attack;
                    path_node.action = "damage_player";
                    //damage_player(alignment, attack); 
                }
                else {
                    //not the player and no unit there. loop
                } 
            } 
            return path_info;
        }

        function damage_player(alignment, amount) {
            life[alignment] -= amount;
            $(".life." + alignment + " h1").text("" + life[alignment]);
        }

        function add_card_to_hand(card_json) {
            var card = $("<li class='card' id='" + card_json.pk + "'>T" + card_json.fields.tech_level + " " + card_json.fields.name + "</li>").appendTo("#friendly_hand");

            card.click( function(event) {

                cancel_cast();

                if (phase != 1 && phase != 3) {
                    //not in an interactive phase, so no clicky
                    return;
                }
                if (tech_level < card_json.fields.tech_level 
                    && tech_level > MAX_TECH) {

                    //we can neither play nor tech up with this
                    //card, so don't allow it to be clicked
                    return;
                }

                $(this).addClass("selected");

                // if the tech level is high enough, select the places
                // on the board we can use this card
                if (tech_level >= card_json.fields.tech_level) {
                    // find valid targets based on card targetting type
                    // e.g. summoning is: friendly board > empty nodes
                    var targets = $(".board." + card_json.fields.target_alignment + " ." + card_json.fields.target_occupant);

                    // highlight valid targets and allow them to respond to click
                    targets.addClass("targettable").click( function (event) {
                        cast($(".card.selected"), $(this));
                    });
                }

                // and if we have already teched fully, 
                // don't allow it to go higher
                if (tech_level < MAX_TECH) {
                    $("#friendly_tech").addClass("targettable").click( function (event) {
                        trash($(".card.selected"));
                    });
                }
            });
        }

        function trash(hand_card) {

            if (phase != 1 && phase != 3) {
                //not in an interactive phase, so no clicky
                return;
            }

            //visually remove from hand
            hand_card.remove();

            tech_up(1);

            if (phase == 1) {
                $("input[name='card1']").val(hand_card.attr("id")); 
                $("input[name='node1']").val('tech'); 
                $("input[name='align1']").val("friendly"); 
            }
            else if (phase == 3) {
                $("input[name='card2']").val(hand_card.attr("id")); 
                $("input[name='node2']").val('tech'); 
                $("input[name='align2']").val("friendly"); 
            }

            next_phase();
        }

        function ai_tech_up(amount) {

            //tech up one notch
            ai_tech_level += amount; 

            if (ai_tech_level > MAX_TECH) tech_level = MAX_TECH;

            $("#ai_tech h1").text("T" + ai_tech_level);
        }
        function tech_up(amount) {

            //tech up one notch
            tech_level += amount; 

            if (tech_level > MAX_TECH) tech_level = MAX_TECH;

            $("#friendly_tech h1").text("T" + tech_level);
        }

        function cast(hand_card, node) { 

            if (phase != 1 && phase != 3) {
                //not in an interactive phase, so no clicky
                return;
            }

            //convert jquery element into json w/ game logic
            var card = hand_cards[hand_card.attr("id")];

            //record it for sending to server
            if (phase == 1) {
                $("input[name='card1']").val(hand_card.attr("id")); 
                $("input[name='node1']").val(node.attr("name")); 
                if (node.parent().hasClass("friendly")) {
                    $("input[name='align1']").val("friendly"); 
                }
                else {
                    $("input[name='align1']").val("ai"); 
                }
            }
            else if (phase == 3) {
                $("input[name='card2']").val(hand_card.attr("id")); 
                $("input[name='node2']").val(node.attr("name")); 
                if (node.parent().hasClass("friendly")) {
                    $("input[name='align2']").val("friendly"); 
                }
                else {
                    $("input[name='align2']").val("ai"); 
                }
            }

            //visually remove from hand
            hand_card.remove(); 
            var card_id = hand_card.attr("id");

            if (card.defense) {
                //create a summon
                node.addClass("unit");
                node.addClass("occupied"); 

                node.removeClass("empty");

                //for lookup of unit behaviour later
                node.attr("id", card_id);

                played_cards[hand_card.attr("id")] = card;

                var unit = $("<div class='unit_piece' id='" + card.pk + "'>" + card.attack + "/" + card.defense + card.attack_type[0] + "</div>").appendTo(node);

                //deep copy the card json onto the board model for convenient access later
                boards["friendly"][node.attr("name")] = $.extend(true, {}, card);
                //boards["friendly"][node.attr("name")] = hand_card.attr("id");
            }

            next_phase();
        }

        function cancel_cast() {
            $(".card").removeClass("selected");

            //clear old targetting events 
            $(".node").removeClass("targettable").unbind("click");

            $("#friendly_tech").removeClass("targettable").unbind("click");
        }

    </script>
{% endblock content %}
